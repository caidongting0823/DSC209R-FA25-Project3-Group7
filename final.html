<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D3 US Earthquakes ‚Äî Stable Map + Multi-select Locations</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://unpkg.com/d3-composite-projections@1.2.0"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>


<style>
/* LIGHT THEME (default) */
:root{
  --bg:#ffffff;               /* page background */
  --text:#111827;             /* primary text */
  --muted:#6b7280;            /* secondary text */
  --grid:#e5e7eb;             /* borders/dividers */
  --accent:#2563eb;           /* blue accent */
  --panel:#ffffff;            /* cards/inputs/sidebar */
}

/* DARK THEME (optional toggle) */
:root[data-theme="dark"]{
  --bg:#0b0e14;
  --text:#e8eef7;
  --muted:#9fb0c6;
  --grid:#243142;
  --accent:#1f62d6;
  --panel:#0f141c;
}

/* Base */
*{ box-sizing:border-box }
html,body{ height:100% }
body{
  margin:0; background:var(--bg); color:var(--text);
  font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  overflow:hidden;
}

/* Header */
header{
  height:52px; display:flex; align-items:center; gap:10px;
  padding:0 12px; border-bottom:1px solid var(--grid);
  white-space:nowrap; overflow:hidden; background:var(--panel);
}
header h1{ font-size:16px; margin:0; font-weight:600; color:var(--text); }
header .sub{ color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis }

/* Layout */
.layout{
  position:absolute; inset:52px 0 0 0;
  display:grid; grid-template-columns:340px 1fr; min-height:0;
}
@media (max-width:900px){ .layout{ grid-template-columns:280px 1fr; } }

/* Sidebar + controls */
.sidebar{
  border-right:1px solid var(--grid);
  background:var(--panel);
  padding:16px 14px; overflow:auto;
}
.filters{ display:grid; gap:16px; min-width:0 }
.section{
  display:grid; gap:8px; padding-bottom:10px;
  border-bottom:1px dashed var(--grid);
}
.section:last-child{ border-bottom:none }

.row{ display:grid; grid-template-columns:90px 1fr; gap:4px; align-items:center }
.label{ color:var(--text); font-size:14px; font-weight:500 }
.valuespan{ color:var(--muted); font-size:12px; font-variant-numeric:tabular-nums }

.slider2{ position:relative; height:26px; display:flex; align-items:center; grid-column:1 / span 2 }
.slider2 input[type="range"]{
  -webkit-appearance:none; appearance:none; position:absolute; width:100%;
  background:none; pointer-events:none;
}
.slider2 input[type="range"]::-webkit-slider-runnable-track{
  height:5px; border-radius:999px; background:#e7efff;
}
.slider2 input[type="range"]::-moz-range-track{
  height:5px; border-radius:999px; background:#e7efff;
}
.slider2 input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance:none; appearance:none;
  width:12px; height:12px; border-radius:50%;
  background:#fff; border:2px solid var(--accent); margin-top:-4px; pointer-events:auto;
}
.slider2 input[type="range"]::-moz-range-thumb{
  width:12px; height:12px; border-radius:50%;
  background:#fff; border:2px solid var(--accent); pointer-events:auto;
}
.slider2 input.lower{ z-index:1 } .slider2 input.upper{ z-index:2 }

.row.values{ grid-template-columns:1fr }
.row.values .label{ display:none }
.valuebox{
  display:grid; grid-template-columns:auto 65px 1fr auto 65px;
  align-items:center; gap:4px; color:var(--muted); font-size:11.5px;
}

input[type="number"]{
  background:var(--panel); color:var(--text);
  border:1px solid var(--grid); border-radius:6px;
  padding:3px 6px; width:60px; margin-left:5px; text-align:center;
}
input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0 }

.checkboxrow{ margin-left:4px }
.checkboxrow label{ display:flex; align-items:center; gap:6px; color:var(--muted); font-size:11.5px; margin:0 }

/* Location search */
.locbox{ position:relative; display:grid; gap:8px }
.locbox input[type="text"]{
  width:100%; padding:6px 8px; border-radius:6px;
  border:1px solid var(--grid); background:var(--panel); color:var(--text); min-width:0;
}
.helper{ color:var(--muted); font-size:11px }

.chips{ display:flex; flex-wrap:wrap; gap:6px }
.chip{
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; border-radius:999px;
  background:#eef2ff; border:1px solid #c7d2fe; color:var(--text);
  font-size:12px;
}
.chip .x{ cursor:pointer; opacity:.7; font-weight:700 }
.chip .x:hover{ opacity:1 }

.loc-suggest{
  position:absolute; left:0; right:0; top:calc(100% + 4px);
  background:var(--panel); border:1px solid var(--grid); border-radius:8px;
  box-shadow:0 8px 24px rgba(0,0,0,.12); max-height:240px; overflow-y:auto;
  z-index:20; display:none;
}
.loc-item{ padding:6px 8px; font-size:12px; color:var(--text); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; cursor:pointer }
.loc-item small{ color:var(--muted); font-size:11px; margin-left:6px }
.loc-item:hover, .loc-item.active{ background:#f3f6fd }

/* Map area */
.view{ position:relative; min-height:0 }
svg{ width:100%; height:100%; display:block }

/* States + borders */
.states{ fill:#f7fafc; stroke:#cbd5e1; stroke-width:.6 }
.state-borders{ fill:none; stroke:#cbd5e1; stroke-width:.6; pointer-events:none }

/* Quake dots */
.quake{ stroke:#000; stroke-opacity:.25 }
.nodata{ fill:#9aa0a6 !important; opacity:.9 }

/* Legend */
.legend-card{
  fill:rgba(255,255,255,.96);
  stroke:var(--grid); stroke-width:1;
  filter:drop-shadow(0 8px 16px rgba(0,0,0,.10));
  rx:10; ry:10;
}
.legend-title{ fill:var(--text); font-weight:600; font-size:12px }

/* Tooltip */
.tooltip{
  position:absolute; pointer-events:none; opacity:0;
  background:#ffffff; color:var(--text); border:1px solid var(--grid);
  padding:8px 10px; font-size:12px; border-radius:8px;
  box-shadow:0 8px 24px rgba(0,0,0,.12);
  transform:translate(-50%,-120%);
}

/* Buttons */
#resetBtn{
  width:100%; padding:8px 0;
  background-color:#f3f8ff; color:#1f2937;
  font-size:13px; font-weight:600;
  border:1px solid var(--grid); border-radius:6px;
  cursor:pointer; transition:all .2s ease-in-out;
}
#resetBtn:hover{ background-color:#e6f0ff }
#resetBtn:active{ transform:scale(0.97) }

#clearLoc{
  background:var(--panel); color:var(--text);
  border:1px solid var(--grid); border-radius:6px;
  padding:4px 8px; cursor:pointer;
}
#clearLoc:hover{ background:#f3f6fd }

/* Insets */
.inset{ fill:none; stroke:#94a3b8; stroke-width:1; shape-rendering:crispEdges }
.inset-label{ fill:var(--muted); font-size:11px; pointer-events:none }
.insetBox{ fill:none; stroke:#94a3b8; stroke-width:1; stroke-dasharray:4 3; shape-rendering:crispEdges }
.insetTitle{ fill:var(--muted); font-size:12px; font-weight:600 }
.nonScaleStroke{ vector-effect:non-scaling-stroke }

/* Misc */
.main-map-mask path{ stroke-width:2 } /* if you ever bring masks back */
</style>


</head>
<body>
<header>
  <h1>US Earthquakes ‚Äî Interactive Map</h1>
  <div class="sub">Interactive D3.js map of U.S. earthquakes over the past 100 years (including Alaska, Hawaii & Puerto Rico/USVI). Each quake is a dot: larger for higher magnitude and color coded for depth. Hover tooltips to reveal details.</div>
</header>

<div class="layout">
  <aside class="sidebar">
    <div class="filters">

      <div class="section">
        <div class="row"><div class="label">Magnitude</div><div class="valuespan" id="magVals">‚Äî</div></div>
        <div class="slider2">
          <input id="magMinR" class="lower" type="range" step="0.1">
          <input id="magMaxR" class="upper" type="range" step="0.1">
        </div>
        <div class="row values">
          <div class="valuebox"><span>Min</span><input id="magMinN" type="number" step="0.1"><span></span><span>Max</span><input id="magMaxN" type="number" step="0.1"></div>
        </div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Depth (km)</div><div class="valuespan" id="depthVals">‚Äî</div></div>
        <div class="slider2">
          <input id="depthMinR" class="lower" type="range" step="10">
          <input id="depthMaxR" class="upper" type="range" step="10">
        </div>
        <div class="row values">
          <div class="valuebox"><span>Min</span><input id="depthMinN" type="number" step="10"><span></span><span>Max</span><input id="depthMaxN" type="number" step="10"></div>
        </div>
        <div class="checkboxrow"><label><input id="includeNA" type="checkbox"> Include N/A</label></div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Year</div><div class="valuespan" id="yearVals">‚Äî</div></div>
        <div class="slider2">
          <input id="yearMinR" class="lower" type="range" step="1">
          <input id="yearMaxR" class="upper" type="range" step="1">
        </div>
        <div class="row values">
          <div class="valuebox"><span>Min</span><input id="yearMinN" type="number" step="1"><span></span><span>Max</span><input id="yearMaxN" type="number" step="1"></div>
        </div>
      </div>

      <div class="section">
        <div class="row">
          <div class="label">Location</div>
          <div class="valuespan helper">Add cities or States</div>
        </div>
        <div class="locbox">
          <input id="locInput" type="text" placeholder="Type: Los Angeles, CA ‚Ä¢ CA ‚Ä¢ California‚Ä¶" autocomplete="off">
          <div id="chips" class="chips"></div>
          <div id="locSuggest" class="loc-suggest"></div>
          <div class="helper">Click to add. Backspace on empty box removes last chip. ‚ÄúClear‚Äù removes all.</div>
        </div>
        <div class="row values">
          <div class="valuebox" style="grid-template-columns:auto auto;">
            <button id="clearLoc" style="background:#0f141c;color:#e8eef7;border:1px solid var(--grid);border-radius:6px;padding:4px 8px;cursor:pointer;">Clear</button>
          </div>
        </div>
      </div>

      <div class="section" style="padding-top:4px;">
        <div class="label" style="opacity:.85;">Note: Click empty map to reset zoom.</div>
      </div>

      <div class="section" style="margin-top: 10px;">
        <button id="resetBtn">üîÑ Reset Filters</button>
      </div>

    </div>
  </aside>

  <div class="view">
    <svg id="svg" preserveAspectRatio="xMidYMid meet"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
</div>

<script>

const normId = v => String(v).padStart(2, "0");

(async function () {
  /* ---------- Small helpers ---------- */
  const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
  const safeExtent = (arr, fallback=[0,1]) => {
    if (!arr || !arr.length) return fallback.slice();
    const e = d3.extent(arr.filter(x => x!=null && isFinite(x)));
    if (e[0]==null || e[1]==null || isNaN(e[0]) || isNaN(e[1])) return fallback.slice();
    if (e[0]===e[1]) return [e[0], e[0]+(typeof e[0]==="number"?1:1)];
    return e;
  };

  /* ---------- State maps ---------- */
  const STATE_ABBR_TO_FULL = {
    AL:"Alabama", AK:"Alaska", AZ:"Arizona", AR:"Arkansas", CA:"California", CO:"Colorado",
    CT:"Connecticut", DE:"Delaware", FL:"Florida", GA:"Georgia", HI:"Hawaii", ID:"Idaho",
    IL:"Illinois", IN:"Indiana", IA:"Iowa", KS:"Kansas", KY:"Kentucky", LA:"Louisiana",
    ME:"Maine", MD:"Maryland", MA:"Massachusetts", MI:"Michigan", MN:"Minnesota",
    MS:"Mississippi", MO:"Missouri", MT:"Montana", NE:"Nebraska", NV:"Nevada",
    NH:"New Hampshire", NJ:"New Jersey", NM:"New Mexico", NY:"New York",
    NC:"North Carolina", ND:"North Dakota", OH:"Ohio", OK:"Oklahoma", OR:"Oregon",
    PA:"Pennsylvania", RI:"Rhode Island", SC:"South Carolina", SD:"South Dakota",
    TN:"Tennessee", TX:"Texas", UT:"Utah", VT:"Vermont", VA:"Virginia", WA:"Washington",
    WV:"West Virginia", WI:"Wisconsin", WY:"Wyoming", DC:"District of Columbia",
    PR:"Puerto Rico", GU:"Guam", VI:"Virgin Islands", AS:"American Samoa", MP:"Northern Mariana Islands"
  };
  const STATE_FULL_TO_ABBR = Object.fromEntries(Object.entries(STATE_ABBR_TO_FULL).map(([k,v])=>[v.toLowerCase(), k]));
  function normalizeStateToken(token){
    if(!token) return {abbr:"", full:""};
    const t = token.trim();
    if (STATE_ABBR_TO_FULL[t.toUpperCase()]) return { abbr:t.toUpperCase(), full: STATE_ABBR_TO_FULL[t.toUpperCase()] };
    const ab = STATE_FULL_TO_ABBR[t.toLowerCase()];
    if (ab) return { abbr:ab, full:STATE_ABBR_TO_FULL[ab] };
    return { abbr:"", full:"" };
  }
  function findStateInText(text){
    if (!text) return null;
    const t = text.toLowerCase();
    let best = null;
    for (const [fullLower, abbr] of Object.entries(STATE_FULL_TO_ABBR)){
      const idx = t.indexOf(fullLower);
      if (idx !== -1){
        if (!best || fullLower.length > best.fullLower.length){
          best = { abbr, full: STATE_ABBR_TO_FULL[abbr], fullLower };
        }
      }
    }
    return best ? { abbr: best.abbr, full: best.full } : null;
  }
  const cleanCityToken = s => (s||"").replace(/^\s*(?:the\s+)?\d{3,4}\s+/i, "").trim();
  const displayLabel = d => (d.locCity && d.locStAbbr)?`${d.locCity}, ${d.locStAbbr}`:(d.locStAbbr||d.locLabel||d.region||"Location");

  /* ---------- Layout & map ---------- */
  const svg = d3.select("#svg");
  const zoomLayer = svg.append("g");
  const mapG = zoomLayer.append("g");
  const ptsG = zoomLayer.append("g");
  const legendG = svg.append("g");
  const insetsG = svg.append("g");
  const tooltip = d3.select("#tooltip");

  function sizeSVG(){
    const r = document.querySelector(".view").getBoundingClientRect();
    const w = Math.max(100, r.width||0);
    const h = Math.max(100, r.height||0);
    svg.attr("viewBox", [0,0,w,h]);
    return { width:w, height:h };
  }
  let { width, height } = sizeSVG();
  let insetBandH = 0; // dynamic height for the top inset strip

  let projection = d3.geoAlbersUsaTerritories();
  let path = d3.geoPath(projection);

  function updateProjection(){
    insetBandH = Math.max(120, height * 0.26);        // top strip reserved for insets
    const mapH = Math.max(100, height - insetBandH);   // height available for main map
    projection = d3.geoAlbersUsaTerritories()
                 .translate([width/2, insetBandH + mapH/2]) // center in lower band
                 .scale(Math.max(300, Math.min(width, mapH) * 1.8));
    path = d3.geoPath(projection);

    mapG.selectAll("path").attr("d", path);

    computeInsetRects();
    recomputeInsetMembership();
  }


    const us = await fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(r=>r.json());

    const allStatesFC   = topojson.feature(us, us.objects.states);
    const stateFeatures = allStatesFC.features;

    const findStateByFIPS = (fips) => stateFeatures.find(s => normId(s.id) === fips);

    // Which states go in the top insets
    const FIPS = { AK: "02", HI: "15", PR: "72" };

    // Padded screen boxes for inset classification (in pixels)
    const PAD = { AK: 60, HI: 30, PR: 35 };
    let insetRects = {}; // { AK:[ [x0,y0],[x1,y1] ], ... }

    function computeInsetRects(){
      ["AK","HI","PR"].forEach(ab=>{
        const f = findStateByFIPS(FIPS[ab]); if(!f) return;
        const b = path.bounds(f);                    // screen-space bounds of land
        const p = PAD[ab] || 20;
        insetRects[ab] = [[b[0][0]-p, b[0][1]-p], [b[1][0]+p, b[1][1]+p]];
      });
    }

    // mark points that belong to AK/HI/PR inset regions (by screen box OR on-land)
    function recomputeInsetMembership(){
      points.forEach(d=>{
        const proj = projection([d.lon, d.lat]);
        let inRect = false;
        if (proj){
          const [x,y] = proj;
          for (const ab of ["AK","HI","PR"]){
            const r = insetRects[ab]; if(!r) continue;
            if (x>=r[0][0] && x<=r[1][0] && y>=r[0][1] && y<=r[1][1]) { inRect = true; break; }
          }
        }
        // on-land is also considered inset (rarely needed but safe)
        const onLand = ["AK","HI","PR"].some(ab=>{
          const f = findStateByFIPS(FIPS[ab]); return f && d3.geoContains(f, [d.lon, d.lat]);
        });
        d._inInset = inRect || onLand;
      });
      // (optional) debug:
      console.log("Inset points flagged:", points.filter(p=>p._inInset).length);
    }


    // IDs we want in the top-row insets only
    const excludedIds = new Set(["02","15","72"]); // AK, HI, PR
    const id2 = s => String(s.id).padStart(2,"0");

    // CONUS only features (remove AK/HI/PR)
    const conusFeatures = stateFeatures.filter(f => !excludedIds.has(id2(f)));

    // Borders only for CONUS
    const conusBorders = topojson.mesh(
      us, us.objects.states,
      (a,b) => a !== b && !excludedIds.has(id2(a)) && !excludedIds.has(id2(b))
    );

    // Draw CONUS states (as individual paths) + borders
    mapG.selectAll("path.state")
      .data(conusFeatures)
      .join("path")
      .attr("class","states")
      .attr("d", path);

    mapG.selectAll("path.state-borders")
      .data([conusBorders])
      .join("path")
      .attr("class","state-borders")
      .attr("d", path);

  // function maskInsetStates(){
  //   const bg = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#0b0e14';
  //   const toMask = stateFeatures.filter(s => excludedIds.has(String(s.id)));
  //   const sel = maskG.selectAll("path").data(toMask, d => d.id);
  //   sel.enter().append("path")
  //       .merge(sel)
  //       .attr("d", path)
  //       .attr("fill", bg)
  //       .attr("stroke", bg);
  //   sel.exit().remove();
  // }


  /* ---------- Data ---------- */
  const data = await d3.csv("data/us_earthquakes_m4.5_cleaned.csv", d=>{
    const depth = (d.depth===""||d.depth==null)?null:+d.depth;
    const mag   = (d.mag===""  ||d.mag==null)?null:+d.mag;
    const lat=+d.latitude, lon=+d.longitude;
    const year = d.time ? new Date(d.time).getUTCFullYear() : null;
    return { time:d.time, year, place:d.place||"", region:d.region||"", depth, mag, lat, lon };
  });
  const points = data.filter(d => isFinite(d.lat) && isFinite(d.lon));

  function cityStateFromPlace(d){
    const place = (d.place||"").trim();
    const region = (d.region||"").trim();

    let m = place.match(/of\s+([^,]+)\s*,\s*([A-Za-z.\s-]{2,})(?:\s+Earthquake)?\s*$/i);
    if (m){
      const city = cleanCityToken(m[1]); const st = normalizeStateToken(m[2]);
      if (city && st.abbr) return {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full};
    }
    m = place.match(/^\s*([^,]+)\s*,\s*([A-Za-z.\s-]{2,})(?:\s+Earthquake)?\s*$/i);
    if (m){
      const city = cleanCityToken(m[1]); const st = normalizeStateToken(m[2]);
      if (city && st.abbr) return {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full};
    }
    if (region){
      const parts = region.split(",").map(s=>s.trim());
      if (parts.length===2){
        const city = cleanCityToken(parts[0]); const st = normalizeStateToken(parts[1]);
        return { label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full };
      } else if (parts.length===1){
        const st = normalizeStateToken(parts[0]);
        if (st.abbr) return { label: st.abbr, city:"", stAbbr:st.abbr, stFull:st.full };
      }
    }
    const found = findStateInText(place) || findStateInText(region);
    if (found) return { label: found.abbr, city:"", stAbbr:found.abbr, stFull:found.full };

    const tail = place.split(',').map(s=>s.trim());
    if (tail.length>=2){
      const st = normalizeStateToken(tail[tail.length-1]);
      const city = cleanCityToken(tail[tail.length-2].replace(/.*of\s+/i,''));
      if (city && st.abbr) return {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full};
    }
    return {label:"", city:"", stAbbr:"", stFull:""};
  }

  points.forEach(d => {
    const cs = cityStateFromPlace(d);
    d.locLabel = cs.label;
    d.locCity  = cs.city;
    d.locStAbbr= cs.stAbbr;
    d.locStFull= cs.stFull;
  });

  // // FIPS ids for states in us-atlas (AK=02, HI=15, PR=72)
  // // FIPS ids must be strings in us-atlas
  // const FIPS = { AK: "02", HI: "15", PR: "72" };

  // const insetFeatures = ["AK","HI","PR"]
  //   .map(ab => findStateByFIPS(FIPS[ab]))
  //   .filter(Boolean);
  //
  // console.log("Inset features:", insetFeatures.map(f => String(f.id).padStart(2,"0")));
  // console.log("Inset points flagged:", points.filter(p => p._inInset).length);


  // points.forEach(d => {
  //   d._inInset = insetFeatures.some(f => d3.geoContains(f, [d.lon, d.lat]));
  // });


  function zoomToBBox(b){
    const [[x0,y0],[x1,y1]] = b;
    const pad = 30;
    const w = x1 - x0 + pad*2, h = y1 - y0 + pad*2;
    const k = Math.min(width / w, height / h) * 0.9;
    const cx = (x0 + x1)/2, cy = (y0 + y1)/2;
    svg.transition().duration(600)
      .call(zoom.transform,
        d3.zoomIdentity
          .translate(width/2, height/2)
          .scale(k)
          .translate(-cx, -cy));
  }

  function drawInsetsTopRow(){
      insetsG.selectAll("*").remove();

      const marginX = 12, marginY = 8, gap = 8;
      const bandH   = insetBandH;                         // from updateProjection()
      const boxW    = (width - marginX*2 - gap*2) / 3;    // three equal boxes across
      const boxH    = bandH - marginY*2;
      const xPos    = [marginX, marginX + boxW + gap, marginX + (boxW + gap)*2];
      const statesOrder = ["AK","HI","PR"];

      statesOrder.forEach((ab, i) => {
        const f = findStateByFIPS(FIPS[ab]);
        if (!f) return;

        const rectX = xPos[i], rectY = marginY;

        // 1) Dotted frame + label
        insetsG.append("rect")
          .attr("class", "insetBox")
          .attr("x", rectX).attr("y", rectY)
          .attr("width", boxW).attr("height", boxH);

        insetsG.append("text")
          .attr("class", "insetTitle")
          .attr("x", rectX + 8).attr("y", rectY + 16)
          .text(ab);

        // 2) Fit the state geometry into the box using a group transform
        const b = path.bounds(f);
        const bW = b[1][0] - b[0][0], bH = b[1][1] - b[0][1];
        const s  = 0.9 * Math.min(boxW / bW, boxH / bH);   // 10% padding
        const cx = (b[0][0] + b[1][0]) / 2;
        const cy = (b[0][1] + b[1][1]) / 2;

        const g = insetsG.append("g")
          .attr("transform",
            `translate(${rectX + boxW/2},${rectY + boxH/2}) scale(${s}) translate(${-cx},${-cy})`);

        // 3) State land
        g.append("path").datum(f)
          .attr("class", "states")
          .attr("d", path);

        // 4) Quakes within that state/territory (geoContains = robust)
        const pts = points.filter(d => passesFilters(d) && d3.geoContains(f, [d.lon, d.lat]));
        g.selectAll("circle").data(pts).join("circle")
          .attr("class", "quake nonScaleStroke")
          // divide by 's' so circles keep the same *screen* size despite the group scale
          .attr("r", d => dataRadius(d.mag, 1) / s)   // insets don't zoom with the main layer
          .attr("transform", d => {
            const p = projection([d.lon, d.lat]);
            return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
          })
          .attr("fill", d => d.depth==null ? "#9aa0a6" : color(clamp(d.depth, dDomMin, dDomMax)))
          .attr("fill-opacity", d => d.depth==null ? 0.75 : alphaScale(d.mag ?? magExt[0]))
          .on("mousemove", (event, d) => {
            const [x,y] = d3.pointer(event, document.querySelector(".view"));
            tooltip.style("left",(x+12)+"px").style("top",(y-12)+"px").style("opacity",1).html(`
              <div><b>${(d.mag!=null?d.mag.toFixed(1):"M?")}</b> ‚Äî <span style="color:var(--muted)">${displayLabel(d)}</span></div>
              <div>Depth: <b>${d.depth==null ? "N/A" : Math.round(d.depth)+" km"}</b></div>
              <div style="color:var(--muted)">${d.time ? new Date(d.time).toUTCString() : ""}</div>
            `);
          })
          .on("mouseleave", ()=> tooltip.style("opacity", 0));
      });
    }



  /* ---------- Location entries (canonical display) ---------- */
  const locMap = new Map();
  for (const d of points){
    if (!d.locLabel) continue;
    const key = d.locLabel;
    const rawPlace = (d.place||"").toLowerCase();
    const rawRegion= (d.region||"").toLowerCase();
    const labelLower = key.toLowerCase();
    const withFull = d.locCity ? `${d.locCity}, ${d.locStFull}` : d.locStFull;
    const withFullLower = (withFull||"").toLowerCase();

    if (!locMap.has(key)){
      locMap.set(key, { label:key, count:1, forms:new Set([labelLower, withFullLower, rawPlace, rawRegion]), stAbbr:d.locStAbbr||"", stFull:d.locStFull||"" });
    } else {
      const e = locMap.get(key);
      e.count++;
      e.forms.add(labelLower);
      if (withFullLower) e.forms.add(withFullLower);
      if (rawPlace) e.forms.add(rawPlace);
      if (rawRegion) e.forms.add(rawRegion);
    }
  }
  const locEntries = Array.from(locMap.values())
    .map(e => ({ label:e.label, count:e.count, forms:Array.from(e.forms), stAbbr:e.stAbbr, stFull:e.stFull }))
    .sort((a,b)=> d3.descending(a.count,b.count) || d3.ascending(a.label,b.label));

  /* ---------- Scales & UI state (safe domains) ---------- */
  const depthExt  = safeExtent(points.map(d=>d.depth).filter(v=>v!=null && isFinite(v)), [0,700]);
  const dDomMin   = clamp(Math.floor(depthExt[0]), 0, 10000);
  const dDomMax   = clamp(Math.ceil(depthExt[1]), dDomMin+1, 10000);

  const magExt    = safeExtent(points.map(d=>d.mag).filter(v=>v!=null && isFinite(v)), [4.5,9.5]);
  const yearExt   = safeExtent(points.map(d=>d.year).filter(v=>v!=null && isFinite(v)), [1900, 2025]);

  // --- Visual encodings ---

  // ---- Depth color (nonlinear) ----
  const depthRamp = d3.piecewise(d3.interpolateHcl, [
    "#e4ffc6", // shallow: light green
    "#fee08b", // yellow
    "#fdae61", // orange
    "#f46d43", // red
    "#305cde"  // very deep: dark blue
  ]);

  // Breakpoints emphasize the shallow crust and upper mantle
  //   0‚Äì15, 15‚Äì35, 35‚Äì70, 70‚Äì120, 120‚Äì200, 200‚Äì275 km
  // Range values allocate *more* of the color ramp to shallow bins.
  const depthWarp = d3.scaleLinear()
    .domain([dDomMin,   15,   35,   70,   120,   200,   dDomMax])   // km
    .range ([0.00,    0.30, 0.48, 0.66, 0.82,  0.93,   1.00])      // ramp t
    .clamp(true);

  // Compose: scaleSequential normalizes x‚Üít, we reconstruct depth from t,
  // then apply the warp ‚Üí ramp. Keeps .domain() working for legend, sliders.
  const color = d3.scaleSequential(t => {
    const depth = dDomMin + t * (dDomMax - dDomMin);
    return depthRamp(depthWarp(depth));
  })
  .domain([dDomMin, dDomMax])
  .clamp(true);

  // Magnitude size: bigger top end + more separation
  const sizeScale = d3.scaleSqrt().domain(magExt).range([3.5, 24]);

  // Larger quakes pop more through clusters
  const alphaScale = d3.scaleLinear().domain(magExt).range([0.55, 0.98]).clamp(true);

  // On-screen radius guard so small events don‚Äôt vanish, big ones don‚Äôt overwhelm
  let currK = 1;            // updated by zoom handler
  const MIN_SCREEN_R = 3.2; // px
  const MAX_SCREEN_R = 26;  // px

  const dataRadius = (mag, k = currK) => {
    const r = sizeScale(mag ?? magExt[0]);
    const ksafe = Math.max(1e-6, k);
    return Math.min(Math.max(r, MIN_SCREEN_R / ksafe), MAX_SCREEN_R / ksafe);
  };



  window.addEventListener("resize", ()=>{
      ({width,height}=sizeSVG());
      updateProjection();
      drawLegend();
      render();
      drawInsetsTopRow();
  });

  let magRange=[magExt[0],magExt[1]], depthRange=[dDomMin,dDomMax], yearRange=[yearExt[0],yearExt[1]];
  const selectedLocs = new Set(); // "City, ST" or "ST"

  /* ---------- Dual sliders init (safe) ---------- */
  function initDual({domain,step,ids,onChange,labelElId}){
    const [loR,hiR,loN,hiN]=[ids.lowerRange,ids.upperRange,ids.lowerNum,ids.upperNum].map(id=>document.getElementById(id));
    const label=document.getElementById(labelElId);
    [loR.min,hiR.min,loN.min,hiN.min]=[domain[0],domain[0],domain[0],domain[0]];
    [loR.max,hiR.max,loN.max,hiN.max]=[domain[1],domain[1],domain[1],domain[1]];
    [loR.step,hiR.step,loN.step,hiN.step]=[step,step,step,step];
    const round=(v)=> step>=1?Math.round(v/step)*step:Math.round(v*10)/10;
    const clampD=v=>clamp(round(v), domain[0], domain[1]);
    const paint=(a,b)=>{const p=v=>100*(v-domain[0])/(domain[1]-domain[0]||1);loR.style.background=`linear-gradient(to right,#dfe8f6 ${p(domain[0])}%,var(--accent) ${p(a)}%,var(--accent) ${p(b)}%,#dfe8f6 ${p(domain[1])}%)`;};
    const sync=(a,b,notify=true)=>{a=clampD(a);b=clampD(b);if(a>b)[a,b]=[b,a];[loR.value,hiR.value,loN.value,hiN.value]=[a,b,a,b];paint(a,b);if(label){const f=step===0.1?x=>(+x).toFixed(1):x=>x;label.textContent=`${f(a)} ‚Äì ${f(b)}`;}if(notify)onChange([a,b]);};
    loR.oninput=()=>sync(+loR.value,+hiR.value);
    hiR.oninput=()=>sync(+loR.value,+hiR.value);
    loN.onchange=()=>sync(+loN.value,+hiN.value);
    hiN.onchange=()=>sync(+loN.value,+hiN.value);
    sync(domain[0],domain[1],false); onChange([domain[0],domain[1]]);
  }
  initDual({ domain:magExt, step:0.1, ids:{lowerRange:'magMinR',upperRange:'magMaxR',lowerNum:'magMinN',upperNum:'magMaxN'}, labelElId:'magVals', onChange:r=>{ magRange=r; render(); drawInsetsTopRow(); }});
  initDual({ domain:[dDomMin,dDomMax], step:10, ids:{lowerRange:'depthMinR',upperRange:'depthMaxR',lowerNum:'depthMinN',upperNum:'depthMaxN'}, labelElId:'depthVals', onChange:r=>{ depthRange=r; render(); drawInsetsTopRow(); }});
  initDual({ domain:yearExt, step:1, ids:{lowerRange:'yearMinR',upperRange:'yearMaxR',lowerNum:'yearMinN',upperNum:'yearMaxN'}, labelElId:'yearVals', onChange:r=>{ yearRange=r; render(); drawInsetsTopRow(); }});

  /* ---------- Location: suggestions + chips ---------- */
  const locInput = document.getElementById("locInput");
  const locPanel = document.getElementById("locSuggest");
  const chipsBox = document.getElementById("chips");
  const clearBtn = document.getElementById("clearLoc");
  let activeIdx = -1;

  const canonQuery = (q)=>{
    const parts = q.split(",").map(s=>s.trim());
    if (parts.length>=2){
      const stateTok = parts.pop();
      const ab = STATE_ABBR_TO_FULL[stateTok.toUpperCase()] ? stateTok.toUpperCase()
               : (STATE_FULL_TO_ABBR[stateTok.toLowerCase()] || "");
      return parts.join(", ") + (ab ? (", " + ab) : "");
    }
    return q;
  };

  function closePanel(){ locPanel.style.display = "none"; activeIdx=-1; }
  function openPanel(){ if (locPanel.childElementCount>0){ locPanel.style.display = "block"; } }

  function renderChips(){
    chipsBox.innerHTML = "";
    for (const label of selectedLocs){
      const span = document.createElement("span");
      span.className = "chip";
      span.innerHTML = `${label} <span class="x" title="Remove">√ó</span>`;
      span.querySelector(".x").onclick = ()=>{ selectedLocs.delete(label); renderChips(); render(); drawInsetsTopRow(); };
      chipsBox.appendChild(span);
    }
  }
  function addSelection(label){
      if (!label) return;
      selectedLocs.add(label);
      renderChips();
      render();
      drawInsetsTopRow();
  }


  function renderSuggestions(qRaw){
    const qTrim = (qRaw||"").trim();
    const qLower = qTrim.toLowerCase();
    locPanel.innerHTML = "";
    if (!qTrim){ closePanel(); return; }

    const abbrOnly = STATE_ABBR_TO_FULL[qTrim.toUpperCase()] ? qTrim.toUpperCase() : "";
    const fullOnlyAbbr = STATE_FULL_TO_ABBR[qLower] || "";

    let results = [];

    if (abbrOnly || fullOnlyAbbr){
      const ab = abbrOnly || fullOnlyAbbr;
      const stateTop = { label: ab, count: 0, _state:true };
      const cityList = locEntries.filter(e => e.stAbbr === ab);
      results = [stateTop, ...cityList];
    } else {
      const qCanon = canonQuery(qTrim).toLowerCase();
      const starts = [], contains = [];
      for (const e of locEntries){
        const mStart = e.forms.some(f => f && (f.startsWith(qCanon) || f.startsWith(qLower)));
        const mCont  = !mStart && e.forms.some(f => f && f.includes(qLower));
        if (mStart) starts.push(e); else if (mCont) contains.push(e);
        if (starts.length >= 10) break;
      }
      results = starts.concat(contains);
    }

    if (!results.length){ closePanel(); return; }

    for (const r of results){
      const div = document.createElement("div");
      div.className = "loc-item";
      if (r._state){
        div.textContent = r.label + " (all)"; const sm=document.createElement("small"); sm.textContent="state"; div.appendChild(sm);
      } else {
        div.textContent = r.label; const sm=document.createElement("small"); sm.textContent=r.count; div.appendChild(sm);
      }
      div.addEventListener("mousedown", (e)=>{ e.preventDefault(); addSelection(r.label); locInput.value = "";});
      locPanel.appendChild(div);
    }
    activeIdx = -1; openPanel();
  }
  function applyTyped(){
    const typed = locInput.value.trim();
    if (!typed) return;
    const ab = STATE_ABBR_TO_FULL[typed.toUpperCase()] ? typed.toUpperCase()
             : (STATE_FULL_TO_ABBR[typed.toLowerCase()] || "");
    if (ab){ addSelection(ab); return; }
    const typedCanon = canonQuery(typed);
    if (locMap.has(typedCanon)) { addSelection(typedCanon); return; }
    if (locMap.has(typed))      { addSelection(typed); return; }
  }
  locInput.addEventListener("input", (e)=> renderSuggestions(e.target.value));
  locInput.addEventListener("keydown", (e)=>{
    const items = Array.from(locPanel.children);
    if (e.key === "ArrowDown" && items.length){
      e.preventDefault(); activeIdx = Math.min(items.length-1, activeIdx+1);
      items.forEach((el,i)=> el.classList.toggle("active", i===activeIdx));
      if (activeIdx>=0) items[activeIdx].scrollIntoView({block:"nearest"});
    } else if (e.key === "ArrowUp" && items.length){
      e.preventDefault(); activeIdx = Math.max(-1, activeIdx-1);
      items.forEach((el,i)=> el.classList.toggle("active", i===activeIdx));
    } else if (e.key === "Enter"){
      e.preventDefault();
      if (activeIdx>=0 && items[activeIdx]){
        const txt = items[activeIdx].textContent.replace(/\s+\(all\)\s*state?$/,'').trim();
        addSelection(txt);
      } else {
        applyTyped();
      }
      locInput.value = ""; closePanel();
    } else if (e.key === "Backspace" && !locInput.value){
      const last = Array.from(selectedLocs).pop(); if (last){ selectedLocs.delete(last); renderChips(); render(); }
    } else if (e.key === "Escape"){ closePanel(); }
  });
  document.addEventListener("click", (e)=>{ if (!document.querySelector(".locbox").contains(e.target)) closePanel(); });
  document.getElementById("clearLoc").onclick = ()=>{ selectedLocs.clear(); renderChips(); render(); drawInsetsTopRow(); };

  /* ---------- Legend ---------- */
    function drawLegend(){
      legendG.selectAll("*").remove();
      const pad = 10;
      const cardW = Math.min(260, Math.max(220, width * 0.22));
      const depthBarH = 12;

      // magnitude legend needs this
      const mags = safeExtent(points.map(d=>d.mag).filter(v=>v!=null && isFinite(v)), [4.5,9.5]);
      const sScale = sizeScale.copy().domain(mags);
      const maxR = sScale(mags[1]);

      const cardH = 26 + depthBarH + 12 + 16 + 8 + 26 + maxR + 12 + 8;
      const x0 = width - cardW - 12;
      const y0 = height - cardH - 12;

      legendG.append("rect")
        .attr("class","legend-card")
        .attr("x",x0).attr("y",y0).attr("width",cardW).attr("height",cardH);

      // --- Depth bar ---
      legendG.append("text")
        .attr("class","legend-title")
        .attr("x",x0+pad).attr("y",y0+18)
        .text("Depth (km)");

      const barW = cardW - pad*2;
      const gradId = "depthGrad";
      const defs = legendG.append("defs");
      const grad = defs.append("linearGradient")
        .attr("id",gradId).attr("x1","0%").attr("x2","100%").attr("y1","0%").attr("y2","0%");

      const [d0,d1] = color.domain();

      // Sample the warped color along the *data* domain to draw a smooth bar
      for (let i=0;i<=48;i++){
        const v = d0 + (i/48)*(d1-d0);
        const off = (v - d0)/(d1 - d0);
        grad.append("stop").attr("offset",`${off*100}%`).attr("stop-color", color(v));
      }

      legendG.append("rect")
        .attr("x",x0+pad).attr("y",y0+26)
        .attr("width",barW).attr("height",depthBarH)
        .attr("rx",6).attr("ry",6)
        .attr("fill",`url(#${gradId})`)
        .attr("stroke","#243142");

      // Ticks at interpretable breaks
      const breaksAll = [0,15,35,70,120,200,275];
      const breaks = breaksAll.filter(v => v>=d0 && v<=d1);
      const tickY = y0 + 26 + depthBarH + 12;
      const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#6b7280';

      breaks.forEach(v=>{
        const t = (v - d0)/(d1 - d0);
        const tx = x0 + pad + barW*t;
        legendG.append("line")
          .attr("x1",tx).attr("x2",tx)
          .attr("y1",y0+26+depthBarH).attr("y2",y0+26+depthBarH+6)
          .attr("stroke", "#8ea0b5");
        legendG.append("text")
          .attr("x",tx).attr("y",tickY).attr("text-anchor","middle")
          .attr("fill", muted).attr("font-size",11)
          .text(v);
      });

      // --- Magnitude (uses your actual size scale) ---
      legendG.append("text")
        .attr("class","legend-title")
        .attr("x",x0+pad).attr("y",tickY+8+16)
        .text("Magnitude");

      const magVals = [mags[0], (mags[0]+mags[1])/2, mags[1]].map(v=>+v.toFixed(1));
      const cxLeft  = x0 + pad + maxR + 4;
      const cxRight = x0 + cardW - pad - maxR - 4;
      const gap = (cxRight - cxLeft) / (magVals.length - 1);
      const circlesY = tickY + 8 + 16 + 10 + 16;

      magVals.forEach((m,i)=>{
        const cx = cxLeft + i*gap, r = sScale(m);
        legendG.append("circle")
          .attr("cx",cx).attr("cy",circlesY).attr("r",r)
          .attr("fill","#e6e6e6").attr("fill-opacity",.9)
          .attr("stroke","#000").attr("stroke-opacity",.4);
        legendG.append("text")
          .attr("x",cx).attr("y",circlesY + r + 12)
          .attr("text-anchor","middle").attr("fill", muted).attr("font-size",11)
          .text(m);
      });
    }

  function passesFilters(d){
    const magOK   = (d.mag  != null && d.mag  >= magRange[0]   && d.mag  <= magRange[1]);
    const yearOK  = (d.year != null && d.year >= yearRange[0]  && d.year <= yearRange[1]);
    const depthOK = d.depth == null ? document.getElementById("includeNA").checked
                                  : (d.depth >= depthRange[0] && d.depth <= depthRange[1]);

    let locOK = true;
    if (selectedLocs.size > 0){
      const st  = (d.locStAbbr||"").toUpperCase();
      const lbl = (d.locLabel||"");
      locOK = (st && selectedLocs.has(st)) || (lbl && selectedLocs.has(lbl));
    }
    return magOK && yearOK && depthOK && locOK;
  }


  /* ---------- Render ---------- */
  function render(){
    try{
      const allowNA = document.getElementById("includeNA").checked;

      const filtered = points.filter(d => passesFilters(d) && !d._inInset);

const sel = ptsG.selectAll("circle.quake").data(filtered, (d,i)=> (d.time||"t")+"|"+i);


      sel.enter().append("circle")
        .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
        .attr("r", d => dataRadius(d.mag))
        .attr("transform", d => {
          const p = projection([d.lon, d.lat]); return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
        })
        .attr("fill", d => d.depth==null ? "#9aa0a6" : color(clamp(d.depth, dDomMin, dDomMax)))
        .attr("fill-opacity", d => d.depth==null ? 0.75 : alphaScale(d.mag ?? magExt[0]))
        .on("mousemove", (event, d) => {
          const [x,y] = d3.pointer(event, document.querySelector(".view"));
          tooltip.style("left",(x+12)+"px").style("top",(y-12)+"px").style("opacity",1).html(`
            <div><b>${(d.mag!=null?d.mag.toFixed(1):"M?")}</b> ‚Äî <span style="color:var(--muted)">${displayLabel(d)}</span></div>
            <div>Depth: <b>${d.depth==null ? "N/A" : Math.round(d.depth)+" km"}</b></div>
            <div style="color:var(--muted)">${d.time ? new Date(d.time).toUTCString() : ""}</div>
          `);
        })
        .on("mouseleave", ()=> tooltip.style("opacity", 0));

      sel
        .attr("r", d => dataRadius(d.mag))
        .attr("fill", d => d.depth==null ? "#9aa0a6" : color(clamp(d.depth, dDomMin, dDomMax)))
        .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
        .attr("fill-opacity", d => d.depth==null ? 0.75 : alphaScale(d.mag ?? magExt[0]))
        .attr("transform", d => {
          const p = projection([d.lon, d.lat]); return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
        });

      sel.exit().remove();
    }catch(err){
      console.error("Render error:", err); // keeps page alive
    }
  }

  updateProjection();
  drawLegend();
  render();
  drawInsetsTopRow();


  // ----- Reset Filters Button Logic -----
  document.getElementById("resetBtn").addEventListener("click", () => {
    function resetDual(minRangeId, maxRangeId, minNumId, maxNumId, minVal, maxVal) {
      const loR = document.getElementById(minRangeId);
      const hiR = document.getElementById(maxRangeId);
      const loN = document.getElementById(minNumId);
      const hiN = document.getElementById(maxNumId);
      loR.value = minVal; hiR.value = maxVal;
      loN.value = minVal; hiN.value = maxVal;
      hiR.dispatchEvent(new Event('input', { bubbles: true }));
    }

    resetDual('magMinR', 'magMaxR', 'magMinN', 'magMaxN',
              sizeScale.domain()[0], sizeScale.domain()[1]);

    resetDual('depthMinR', 'depthMaxR', 'depthMinN', 'depthMaxN',
              color.domain()[0], color.domain()[1]);

    resetDual('yearMinR', 'yearMaxR', 'yearMinN', 'yearMaxN',
              yearExt[0], yearExt[1]);

    d3.select("#includeNA").property("checked", false);

    d3.select("#locInput").property("value", "");
    if (typeof selectedLocs !== "undefined") {
      selectedLocs.clear();
      if (typeof renderChips === "function") renderChips();
    }

    render();
    drawInsetsTopRow();
  });


  /* ---------- Zoom ---------- */
  const zoom = d3.zoom().scaleExtent([0.9, 8]).on("zoom", (ev)=>{
    currK = ev.transform.k;
    zoomLayer.attr("transform", ev.transform);
    // Update radii so small dots keep the minimum screen size at every zoom
    ptsG.selectAll("circle.quake").attr("r", d => dataRadius(d.mag, currK));
  });

  svg.call(zoom).on("click", (e)=>{
    if (e.target === svg.node()) svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
  });

  document.getElementById("includeNA").addEventListener("change", ()=>{ render(); drawInsetsTopRow(); });
})();
</script>
</body>
</html>
